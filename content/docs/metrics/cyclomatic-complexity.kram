---
title: "Cyclomatic Complexity"
resources:
- http://en.wikipedia.org/wiki/Cyclomatic_complexity
---

In SidekickJS, cyclomatic complexity contributes to debt as follows:

<table class="debt">
  <tr>
    <th>Complexity</th>
    <th>Debt</th>
  </tr>
  <tr>
    <td>10 - 15</td><td>1 debt per unit of complexity</td>
  </tr>
  <tr>
    <td>16+</td><td>1.5 debt per unit of complexity</td>
  </tr>
</table>

Cyclomatic complexity measures the unique paths through your code. The more unique paths your code has, the more possible ways there are for it to go wrong. Whether you're writing unit tests, or reasoning about code during debugging, it's harder the higher the cyclomatic complexity is.

As an example, consider the following function from Backbone.js:

~~~javascript
changedAttributes: function(diff) {
  if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
  var val, changed = false;
  var old = this._changing ? this._previousAttributes : this.attributes;
  for (var attr in diff) {
    if (_.isEqual(old[attr], (val = diff[attr]))) continue;
    (changed || (changed = {}))[attr] = val;
  }
  return changed;
}
~~~

How many ways could we go through the code? It's clear that every time we add an `if` statement, there are two possible ways for the code to go. Equally a `for` loop may never execute the body of its loop if the object is empty. In total, we have the following branches:

- `if(!diff)`
- `this.hasChanged() ?`
- `this._changing ?`
- `for (var attr in diff)`
- `if(_.isEqual`
- `changed || (changed = {})`

The cyclomatic complexity of the method is 6. The actual number of paths through the code is 2<sup>6</sup>, or 64! Obviously some paths are mutually exclusive, but it gives you an idea of why seemingly simple code can hide difficult bugs.

So: what level of cyclomatic complexity is acceptable? Empirical experience suggests great code-bases like Backbone's rarely go above 8. Like all [metrics](/metrics/overview) it's an indicator for problems, and not a perfect indicator. But if you have a really complex method, consider one of the solutions below.

### Switch statements

Switch statements are traditionally penalised very harshly by cyclomatic complexity, but may be a good solution to a problem. There are two main types goals of switch statement: flow control, and data-driven. Using switch statements for flow control is 'bad' complexity: it makes reasoning about code harder. But a big, data-driven table is not as complex: you're doing similar, sensible things in reaction to different input. Parsing is a good example of the 'good' switch statement.

SidekickJS will place a limit on the complexity generated by the 'good' switch statements in the future.

## Solutions

### Split up the method

If you have a huge number of paths through a method, perhaps it's doing too much? Are there logical sub-tasks you could name and split out? This makes debugging much easier, as you can test each works in isolation, and debug the whole aggregate procedure sub-procedure by sub-procedure.

### Replace conditionals with polymorphism

If you have code that checks what type of object you have, via `if` statements or `switch`, you can define the different behaviour to take in each case via polymorphism.

### Solve problems once

Don't make redundant checks in your code. If you have a special case to handle, do it once, and then continue, don't make the same check in every place required in the procedure.

### Reduce ambiguity

If you're doing a lot of checking for null, or for input that might be a string or a number, consider why. Could you ensure that the method is always fed correct input earlier in the chain? It's best for each component in your code to pass on a very well defined output: a method will always return a number is simpler than a method that returns either a null, a number, or a string. That way you have less guarding code as you either coerce data to a know type, or throw an error at the source, rather than checking downstream.

